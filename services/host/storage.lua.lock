local command = require("services.command")
local lineLib = require("libraries.GNLineLib")

local serverData = client.getServerData()
local configName = 'storage_' .. (serverData.ip and serverData.ip:gsub('^.-;', '') or serverData.name):gsub(' ', '_')

config:setName(configName)
local ridstates = config:load("ridstates")
if ridstates then ridstates = parseJson(ridstates) else ridstates = {} end
local remembered = config:load("data")
if remembered then remembered = parseJson(remembered) else remembered = {} end
printTable(remembered,2)
local offsets = {
   north = vectors.vec3(-1, 0, 0),
   south = vectors.vec3(1, 0, 0),
   west = vectors.vec3(0, 0, 1),
   east = vectors.vec3(0, 0, -1)
}

local last_rid = ""
local last_screen = ""
local block_interacted = nil --[[@type BlockState]]

keybinds:fromVanilla("key.use").press = function()
   block_interacted = player:getTargetedBlock(true, 5)
   if block_interacted.properties.type == "right" then -- make sure double chest blocks are identified as one
      block_interacted:setPos(block_interacted:getPos():add(offsets[block_interacted.properties.facing]))
   end
end
local function isContainer(block)
   return not ((not block:getEntityData() or not block:getEntityData().Items) and not block.id:find("shulker") and not block.id:find("chest$"))
end

local container_screens = {
   ["net.minecraft.class_476"] = true, -- Chest, Ender Chest, Barrel
   ["net.minecraft.class_480"] = true, -- Dispenser, Dropper
   ["net.minecraft.class_488"] = true, -- Hopper
   ["net.minecraft.class_495"] = true  -- Shulker Box
}

local save_timer = 0
events.WORLD_TICK:register(function()
   local screen = host:getScreen()
   if last_screen ~= screen then
      last_screen = screen
      if block_interacted then -- load cached rid for that block
         local might_rid = last_rid[block_interacted:getPos():toString().."rid"]
         if might_rid and false then last_rid = might_rid end
      end
   end
   save_timer = save_timer - 1
   if block_interacted and container_screens[screen] and isContainer(block_interacted) and save_timer < 0 then -- container + screen
      save_timer = 20
      local bpos = block_interacted:getPos()
      local id = tostring(bpos:toString())

      -- Collect Container Data
      for i = 0, 60, 1 do
         local success, output = pcall(host.getScreenSlot, host, "container." .. i)
         if not success then break end
         local item = output
         if not remembered[id] then 
            remembered[id] = {pos = bpos,data = {}} 
            print("new chest")
            if block_interacted.properties.type then
               local to
               if block_interacted.properties.type == "left" then
                  to = bpos + offsets[block_interacted.properties.facing]
               else
                  to = bpos - offsets[block_interacted.properties.facing]
               end
               local p = bpos
               local e = to
               local min = vectors.vec3(
                  math.min(p.x,e.x),
                  math.min(p.y,e.y),
                  math.min(p.z,e.z)
               )
               local max = vectors.vec3(
                  math.max(p.x,e.x),
                  math.max(p.y,e.y),
                  math.max(p.z,e.z)
               )
               remembered[id].pos = min
               remembered[id].extent = max + 1
            else
               remembered[id].extent = bpos + 1
            end
         end
         if item.id ~= "minecraft:air" then
            remembered[id].data[item.id] = true
         end
      end

      -- Generate RID to detect changes
      local rid = block_interacted.id .. ":" .. block_interacted:getPos():toString() .. ":" .. table.concat(remembered[id].data,":")

      -- Write to file if something changed
      if last_rid ~= rid then
         last_rid = rid
         config:setName(configName)
         ridstates[block_interacted:getPos():toString().."rid"] = rid
         print("saved")
         config:save("data",toJson(remembered))
         config:save("ridstates",toJson(ridstates))
      end
   end
end)

local outlines = {}

local function drawCubeOutline(from,to,width,depth,color)
   local corners = {
      from,
      vectors.vec3(to.x, from.y, from.z),
      vectors.vec3(to.x, to.y, from.z),
      vectors.vec3(from.x, to.y, from.z),
      vectors.vec3(from.x, from.y, to.z),
      vectors.vec3(to.x, from.y, to.z),
      to,
      vectors.vec3(from.x, to.y, to.z)
   }

   -- Connect the corners to form the cube outline
   outlines[#outlines+1] = lineLib:newLine():from(corners[1]):to(corners[2]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[2]):to(corners[3]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[3]):to(corners[4]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[4]):to(corners[1]):depth(depth):width(width):color(color)

   outlines[#outlines+1] = lineLib:newLine():from(corners[5]):to(corners[6]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[6]):to(corners[7]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[7]):to(corners[8]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[8]):to(corners[5]):depth(depth):width(width):color(color)

   outlines[#outlines+1] = lineLib:newLine():from(corners[1]):to(corners[5]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[2]):to(corners[6]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[3]):to(corners[7]):depth(depth):width(width):color(color)
   outlines[#outlines+1] = lineLib:newLine():from(corners[4]):to(corners[8]):depth(depth):width(width):color(color)
end

local function makeOutlineBox(from,to,clr)
   drawCubeOutline(from,to,0.03,-0.01,clr)
   drawCubeOutline(from,to,0.01,-0.9,clr)
end

command.register(function(words)
   if words[1] == "f" then
      for key, value in pairs(outlines) do
         value:delete()
      end
      outlines = {}
      if #words == 2 then
         if words[2] == "all" then
            for idpos, chest in pairs(remembered) do
               makeOutlineBox(chest.pos,chest.extent,vectors.vec3(.5,.5,.5))
            end
            command.announce("showing all recorded chests")
         else
            local i = 0
            for key, value in pairs(outlines) do
               value:delete()
            end
            
            for idpos, chest in pairs(remembered) do
               local found = false
               for item, _ in pairs(chest) do
                  if item ~= "pos" and item ~= "extent" and item:find(words[2]) then
                     i = i + 1
                     found = true
                     break
                  end
               end
               if found then
                  makeOutlineBox(chest.pos,chest.extent,vectors.vec3(1,1,1))
               end
            end
            if i > 0 then
               if i == 1 then
                  command.announce('found a container containing \\"' .. words[2] .. '\\"')
               else
                  command.announce("found " .. i .. ' containers containing \\"' .. words[2] .. '\\"')
               end
            else
               command.announce("no results")
            end
         end
      elseif #words == 1 then
         command.announce("cleared")
      end
   end
end)